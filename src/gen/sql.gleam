//// Code generated by parrot. DO NOT EDIT.
////

import gleam/option.{type Option}
import gleam/dynamic/decode
import gleam/time/timestamp.{type Timestamp}
import parrot/sql

pub type GetAuthor {
  GetAuthor(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn get_author(id: Int){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
WHERE
  id = ?
LIMIT
  1"
  #(sql, [sql.ParamInt(id)])
}

pub fn get_author_decoder() -> decode.Decoder(GetAuthor) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(GetAuthor(id: , created_at: , name: , bio: ))
}

pub type ListAuthors {
  ListAuthors(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn list_authors(){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
ORDER BY
  name"
  #(sql, Nil)
}

pub fn list_authors_decoder() -> decode.Decoder(ListAuthors) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(ListAuthors(id: , created_at: , name: , bio: ))
}

pub type NewAuthorsSince {
  NewAuthorsSince(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn new_authors_since(after: Timestamp){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
WHERE
  authors.created_at > ?
ORDER BY
  name"
  #(sql, [sql.ParamTimestamp(after)])
}

pub fn new_authors_since_decoder() -> decode.Decoder(NewAuthorsSince) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(NewAuthorsSince(id: , created_at: , name: , bio: ))
}

pub fn create_author(name: String, bio: String){
  let sql = "INSERT INTO
  authors (name, bio)
VALUES
  (?, ?)"
  #(sql, [sql.ParamString(name), sql.ParamString(bio)])
}

pub fn delete_author(id: Int){
  let sql = "DELETE FROM authors
WHERE
  id = ?"
  #(sql, [sql.ParamInt(id)])
}

pub type CountAuthors {
  CountAuthors(
    count: Int
  )
}

pub fn count_authors(){
  let sql = "SELECT
  count(*)
FROM
  authors"
  #(sql, Nil)
}

pub fn count_authors_decoder() -> decode.Decoder(CountAuthors) {
  use count <- decode.field(0, decode.int)
  decode.success(CountAuthors(count: ))
}

pub type AuthorPosts {
  AuthorPosts(
    posts_id: Int,
    posts_created_at: Timestamp,
    author_id: Int,
    title: String,
    body: Option(String),
    authors_id: Int,
    authors_created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn author_posts(id: Int){
  let sql = "SELECT
  posts.id, posts.created_at, author_id, title, body, authors.id, authors.created_at, name, bio
FROM
  posts
  INNER JOIN authors on authors.id = posts.author_id
WHERE
  authors.id = ?"
  #(sql, [sql.ParamInt(id)])
}

pub fn author_posts_decoder() -> decode.Decoder(AuthorPosts) {
  use posts_id <- decode.field(0, decode.int)
  use posts_created_at <- decode.field(1, sql.datetime_decoder())
  use author_id <- decode.field(2, decode.int)
  use title <- decode.field(3, decode.string)
  use body <- decode.field(4, decode.optional(decode.string))
  use authors_id <- decode.field(5, decode.int)
  use authors_created_at <- decode.field(6, sql.datetime_decoder())
  use name <- decode.field(7, decode.string)
  use bio <- decode.field(8, decode.optional(decode.string))
  decode.success(AuthorPosts(posts_id: , posts_created_at: , author_id: , title: , body: , authors_id: , authors_created_at: , name: , bio: ))
}