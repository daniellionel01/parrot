//// Code generated by parrot. DO NOT EDIT.
////

import gleam/option.{type Option}
import gleam/dynamic/decode
import gleam/time/timestamp.{type Timestamp}
import parrot/sql

pub type GetAuthor {
  GetAuthor(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn get_author(id: Int){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
WHERE
  id = $1
LIMIT
  1"
  #(sql, [sql.ParamInt(id)])
}

pub fn get_author_decoder() -> decode.Decoder(GetAuthor) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(GetAuthor(id: , created_at: , name: , bio: ))
}

pub type ListAuthors {
  ListAuthors(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn list_authors(){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
ORDER BY
  name"
  #(sql, Nil)
}

pub fn list_authors_decoder() -> decode.Decoder(ListAuthors) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(ListAuthors(id: , created_at: , name: , bio: ))
}

pub type NewAuthorsSince {
  NewAuthorsSince(
    id: Int,
    created_at: Timestamp,
    name: String,
    bio: Option(String)
  )
}

pub fn new_authors_since(after: Timestamp){
  let sql = "SELECT
  id, created_at, name, bio
FROM
  authors
WHERE
  authors.created_at > $1
ORDER BY
  name"
  #(sql, [sql.ParamTimestamp(after)])
}

pub fn new_authors_since_decoder() -> decode.Decoder(NewAuthorsSince) {
  use id <- decode.field(0, decode.int)
  use created_at <- decode.field(1, sql.datetime_decoder())
  use name <- decode.field(2, decode.string)
  use bio <- decode.field(3, decode.optional(decode.string))
  decode.success(NewAuthorsSince(id: , created_at: , name: , bio: ))
}

pub fn create_author(name: String, bio: String){
  let sql = "INSERT INTO
  authors (name, bio)
VALUES
  ($1, $2)"
  #(sql, [sql.ParamString(name), sql.ParamString(bio)])
}

pub fn delete_author(id: Int){
  let sql = "DELETE FROM authors
WHERE
  id = $1"
  #(sql, [sql.ParamInt(id)])
}

pub type CountAuthors {
  CountAuthors(
    count: Int
  )
}

pub fn count_authors(){
  let sql = "SELECT
  count(*)
FROM
  authors"
  #(sql, Nil)
}

pub fn count_authors_decoder() -> decode.Decoder(CountAuthors) {
  use count <- decode.field(0, decode.int)
  decode.success(CountAuthors(count: ))
}