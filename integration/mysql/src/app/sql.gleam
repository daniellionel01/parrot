//// Code generated by parrot. DO NOT EDIT.
////

import gleam/dynamic/decode
import gleam/option.{type Option}
import gleam/time/timestamp.{type Timestamp}
import parrot/dev

pub type UsersStatus {
  Like
  Neutral
}

pub fn users_status_decoder() {
  use variant <- decode.then(decode.string)
  case variant {
    "like" -> decode.success(Like)
    "neutral" -> decode.success(Neutral)
    _ -> decode.failure(Like, "UsersStatus")
  }
}

pub fn users_status_to_string(val: UsersStatus) {
  case val {
    Like -> "like"
    Neutral -> "neutral"
  }
}

pub type Simple {
  Simple(col_0: Int)
}

pub fn simple() {
  let sql = "select 1"
  #(sql, [], simple_decoder())
}

pub fn simple_decoder() -> decode.Decoder(Simple) {
  use col_0 <- decode.field(0, decode.int)
  decode.success(Simple(col_0:))
}

pub type GetUser {
  GetUser(
    id: Int,
    username: String,
    created_at: Option(Timestamp),
    status: Option(UsersStatus),
    admin: Bool,
  )
}

pub fn get_user(id id: Int) {
  let sql =
    "SELECT
  id, username, created_at, status, admin
FROM
  users
WHERE
  id = ?
LIMIT
  1"
  #(sql, [dev.ParamInt(id)], get_user_decoder())
}

pub fn get_user_decoder() -> decode.Decoder(GetUser) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use created_at <- decode.field(2, decode.optional(dev.datetime_decoder()))
  use status <- decode.field(3, decode.optional(users_status_decoder()))
  use admin <- decode.field(4, dev.bool_decoder())
  decode.success(GetUser(id:, username:, created_at:, status:, admin:))
}

pub type ListUsers {
  ListUsers(
    id: Int,
    username: String,
    created_at: Option(Timestamp),
    status: Option(UsersStatus),
    admin: Bool,
  )
}

pub fn list_users() {
  let sql =
    "SELECT
  id, username, created_at, status, admin
FROM
  users
ORDER BY
  created_at DESC"
  #(sql, [], list_users_decoder())
}

pub fn list_users_decoder() -> decode.Decoder(ListUsers) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use created_at <- decode.field(2, decode.optional(dev.datetime_decoder()))
  use status <- decode.field(3, decode.optional(users_status_decoder()))
  use admin <- decode.field(4, dev.bool_decoder())
  decode.success(ListUsers(id:, username:, created_at:, status:, admin:))
}

pub fn create_user(username username: String) {
  let sql =
    "INSERT INTO
  users (username)
VALUES
  (?)"
  #(sql, [dev.ParamString(username)])
}

pub fn update_user_username(username username: String, id id: Int) {
  let sql =
    "UPDATE users
SET
  username = ?
WHERE
  id = ?"
  #(sql, [dev.ParamString(username), dev.ParamInt(id)])
}

pub fn delete_user(id id: Int) {
  let sql =
    "DELETE FROM users
WHERE
  id = ?"
  #(sql, [dev.ParamInt(id)])
}

pub type GetUserByUsername {
  GetUserByUsername(
    id: Int,
    username: String,
    created_at: Option(Timestamp),
    status: Option(UsersStatus),
    admin: Bool,
  )
}

pub fn get_user_by_username(username username: String) {
  let sql =
    "SELECT
  id, username, created_at, status, admin
FROM
  users
WHERE
  username = ?
LIMIT
  1"
  #(sql, [dev.ParamString(username)], get_user_by_username_decoder())
}

pub fn get_user_by_username_decoder() -> decode.Decoder(GetUserByUsername) {
  use id <- decode.field(0, decode.int)
  use username <- decode.field(1, decode.string)
  use created_at <- decode.field(2, decode.optional(dev.datetime_decoder()))
  use status <- decode.field(3, decode.optional(users_status_decoder()))
  use admin <- decode.field(4, dev.bool_decoder())
  decode.success(GetUserByUsername(id:, username:, created_at:, status:, admin:))
}

pub type PostsByUsername {
  PostsByUsername(id: Int, title: String, user_id: Int)
}

pub fn posts_by_username(username username: String) {
  let sql =
    "select
  id,
  title,
  user_id
from posts
where user_id = (
  select id
  from users
  where username = ?
)"
  #(sql, [dev.ParamString(username)], posts_by_username_decoder())
}

pub fn posts_by_username_decoder() -> decode.Decoder(PostsByUsername) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use user_id <- decode.field(2, decode.int)
  decode.success(PostsByUsername(id:, title:, user_id:))
}

pub type PostsByAdmins {
  PostsByAdmins(id: Int, title: String, user_id: Int)
}

pub fn posts_by_admins() {
  let sql =
    "select
  id,
  title,
  user_id
from posts
where user_id in (
  select id
  from users
  where users.role = 'admin'
)"
  #(sql, [], posts_by_admins_decoder())
}

pub fn posts_by_admins_decoder() -> decode.Decoder(PostsByAdmins) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use user_id <- decode.field(2, decode.int)
  decode.success(PostsByAdmins(id:, title:, user_id:))
}
